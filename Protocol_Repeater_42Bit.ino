/*  
***********************************************************************************************************************************
OK-Version juergs, 30.12.2016
*   Unknown 433Mhz weather sensor decoder.
*  http://arduino.cc/forum/index.php/topic,142871.msg1106336.html#msg1106336
*  Rising edge
__           ___       ___    ___
  |         |  |      |  |   |  |
  |_________|  |______|  |___|  |_......

|  Sync      |    1    |  0   |
|  8320us    | 4500us  | 2530us

00          BB CC LLLLMMMMHHHH LLLLHHHH ????????
LD Rnd.Nmbr BT CH TemperatureF Humidity CRC?????
00 11101001 10 01 110001010110 10000010 00101101

Which is:
=========
Battery=2[best] Channel=1[CH2] Temperature=72.8F [22.67*C] Humidity=40%
Leading 2 zeroes (“LD” - lead).  They are seen in every packet read during measures.
This ‘identify’ the sensor. “Probably to align the AGC circuit on the receiver.” [Riva]
RandomNumber(“Rnd.Nmbr”)    Random number generated by device every battery change.

“it's probably so multiple senders can be connected to a single base station.” [Riva]
Preambles(Random Numbers) seen (+ decimal values - read straight and LLLLHHHH way):

1110 1001 [straight: 233 | LLLLHHHH: 158 ]
0001 1100 [straight:  28 | LLLLHHHH: 193 ]
1000 1110 [straight: 142 | LLLLHHHH: 232 ]
0011 0001 [straight:  49 | LLLLHHHH:  19 ]
1011 1111 [straight: 191 | LLLLHHHH: 251 ]
0100 1011 [straight:  75 | LLLLHHHH: 180 ]
1010 0100 [straight: 164 | LLLLHHHH:  74 ]

Battery (“BT”):
==============
Battery status indicator. Values seen:
00 - dec: 0 [low] (doesn’t mean ‘low’ on weather station tho)
01 - dec: 1 [2/3]
10 - dec: 2 [best]

Channel (“CH”):
=============
CH# - channel number
00 - CH1
01 - CH2
10 - CH3

Humidity: (HHHH + LLLL)
=========
Humidity is stored as low/high order nibbles. In the example above take the first 4 bits and tack them on the end of the next 4 bits. 11010101 becomes 01011101 that is 93 decimal. [source]
TemperatureF: (HHHH + MMMM + LLLL) - in Fahrenheit (even with Celsius shown on LCD)
Looks like temperature is transmitted as 12 bits in 3x nibbles ranging from low to high nibbles.
A fixed offset of 900 is applied to the temperature value
so 0 degrees F = 900 and each degree F change is 10 decimal.
In the example 001101000101 becomes 010101000011 that is 1347 decimal.
1347-900 = 447
447/10 = 44.7
44.7F = 7.1C [source]
CRC:
(unknown yet)
Assuming CRC is same as humidity - LLLL + HHHH, seen LLLL values were:
0000 - dec: 0
0001 - dec: 1
1000 - dec: 8
1001 - dec: 9
1010 - dec: 10
It has to be something with channel value, as you can see in these readings:
001010010001 01 011011110011 00100011 10010101 - Battery=1 Channel=1 Temperature=11.4F Humidity=50%
001010010001 10 011011110011 00100011 10011000 - Battery=1 Channel=2 Temperature=11.4F Humidity=50%
-- same values of TEMP and HUM, different random:
001011111100 01 011001110110 00000011 00001111 - Battery=0 Channel=1 Temperature=75.4F Humidity=48%
000011000100 01 011001110110 00000011 10001011 - Battery=0 Channel=1 Temperature=75.4F Humidity=48%
-- channel number dependent
001010010001 00 011011110011 00100011 00010111 - Battery=1 Channel=0 Temperature=11.4F Humidity=50% CH-1
001010010001 01 011011110011 00100011 10010101 - Battery=1 Channel=1 Temperature=11.4F Humidity=50% CH-2
001010010001 10 011011110011 00100011 10011000 - Battery=1 Channel=2 Temperature=11.4F Humidity=50% CH-3


** two active devices 
2017-01-07 16:23:46 CUL_TCM97001 Unknown Code: 030311848080
2017-01-07 16:24:00 CUL_TCM97001 Unknown Code: 06C5D1888240

000000110000001100010001100001001000000010 - Battery=0 Channel=1 Temperature=[F]: 71.2   [C]: 21.8    Humidity=33%
1..........10...........20............30..........40.. => 42 Bit  (ohne Präambel)
0000 0011 0000  0011 0001  0001 1000 0100 1000 0000 10     - Battery=0 Channel=1 Temperature=[F]: 71.2   [C]: 21.8    Humidity=33%
   0    3    0     3    1     1    8    4    8    0 ??


	Checksumme
	Humidity
	Temperature
	Channel
	Tendency (Batteriewechsel?)
	SensorID
	Start-Indicators

***********************************************************************************************************************************
***********************************************************************************************************************************
*/

#include "SerialCommand.h"
#include <avr/pgmspace.h>   //enable use of flash memory
//--------------------------------------------------------------------------
// Defines
#define allDataBits		42                                    // Number of data bits to expect
#define LED_EXTERN		12	

//--- isrFlags bit numbers
#define F_HAVE_DATA		1                                     // 0=Nothing in read buffer, 1=Data in read buffer
#define F_GOOD_DATA		2                                     // 0=Unverified data, 1=Verified (2 consecutive matching reads)
#define F_CARRY_BIT		3                                     // Bit used to carry over bit shift from one long to the other
#define F_STATE			7                                         // 0=Sync mode, 1=Data mode
#define ulong			unsigned long

//--- Constants
const unsigned long		sync_MIN = 8120;                      // Minimum Sync time in micro seconds
const unsigned long		sync_MAX = 8520;
const unsigned long		bit1_MIN = 4300;
const unsigned long		bit1_MAX = 4700;
const unsigned long		bit0_MIN = 2330;
const unsigned long		bit0_MAX = 2730;
const unsigned long		glitch_Length = 300;                  // Anything below this value is a glitch and will be ignored.

															  //--- Interrupt variables
unsigned long			fall_Time = 0;                              // Placeholder for microsecond time when last falling edge occured.
unsigned long			rise_Time = 0;                              // Placeholder for microsecond time when last rising edge occured.
byte					bit_Count = 0;                                       // Bit counter for received bits.
unsigned long			build_Buffer[] = { 0, 0 };                    // Placeholder last data packet being received.
volatile unsigned long	read_Buffer[]  = { 0, 0 };            // Placeholder last full data packet read.
volatile byte			isrFlags = 0;                               // Various flag bits
volatile boolean		isInReadMode = false; 
volatile boolean		hasAutoStarted = false;			// over

FILE					serial_stdout;					// needed for printf 
SerialCommand			sCmd;							// The demo SerialCommand object

unsigned long			wait_time = 0;					// wait for autostart

//------------------------------------------------------------------

//------------------------------------------------------------------
void setup() 
{
	pinMode(LED_BUILTIN , OUTPUT);      // Configure the onboard LED for output
	pinMode(LED_EXTERN, OUTPUT);
	digitalWrite(LED_BUILTIN, LOW);    // default to LED off
	digitalWrite(LED_EXTERN, LOW);    // default to LED off

	//--- set up stdout
	fdev_setup_stream(&serial_stdout, serial_putchar, NULL, _FDEV_SETUP_WRITE);
	stdout = &serial_stdout;

	Serial.begin(57600);

	// Setup callbacks for SerialCommand commands
	sCmd.addCommand("ON", LED_on);          // Turns LED on
	sCmd.addCommand("OFF", LED_off);         // Turns LED off
	sCmd.addCommand("BLINK", Blink);         // Turns LED off
	sCmd.addCommand("HELLO", sayHello);        // Echos the string argument back
	sCmd.addCommand("P", processCommand);		// Converts two arguments to integers and echos them back
	sCmd.addCommand("START", process433_start);		// runs into processmode 
	sCmd.addCommand("STOP", process433_stop);		// stop int-reading
	sCmd.setDefaultHandler(unrecognized);      // Handler for command that isn't matched  (says "What?")

	printf("\n*** Ready for processing serial commands... \n");
	printf("*******************************************\n"); 
	printf("Possible commands: \n");
	printf("\t ON \t- LED ON \n");
	printf("\t OFF \t- LED off \n");
	printf("\t BLINK \t- blinks LED \n");
	printf("\t HELLO \t- welcome message \n");
	printf("\t P \t- sample with arguments \n");
	printf("\t START \t- start ISR-processing  \n");
	printf("\t STOP \t- stops ISR processing \n");
	printf("*******************************************\n");
	printf("**Don't forget to initiate START-command **\n");
	printf("** autostart enabled after 10 seconds    **\n");
	printf("*******************************************\n\n");

	wait_time = millis(); 
}
//------------------------------------------------------------------
void loop()
{
  if ( (millis() - wait_time > 10000) && (!hasAutoStarted)) 
  { 
		//--- autostart reading 
		printf("Autostarting...\n");
		process433_start(); 
		hasAutoStarted = true; 
		printf("Autostarted!\n");
  }

  sCmd.readSerial();     // We don't do much, just process serial commands

  if (isInReadMode) 
	loop433();			// get readings if necessary	
}
//--------------------------------------------------------------------------------
void loop433()
{
	unsigned long myData0 = 0;
	unsigned long myData1 = 0;
	unsigned long tmp = 0;
	uint8_t buf[4] = { 0,0,0,0 };


	//if ((bitRead(isrFlags, F_GOOD_DATA) == 1) && (bitRead(isrFlags, F_HAVE_DATA) == 1) )
	if (bitRead(isrFlags, F_GOOD_DATA) == 1 )
	{

		// We have at least 2 consecutive matching reads
		myData0 = read_Buffer[0]; // Read the data spread over 2x 32 variables
		myData1 = read_Buffer[1];

		tmp = myData1 >> 2; 
		buf[3] = tmp >> 24;
		buf[2] = tmp >> 16;
		buf[1] = tmp >> 8;
		buf[0] = tmp;

		printf("Data: ");
		printBits(sizeof(tmp), &tmp);

		//printf("Data: %x - %x - %x - %x\t", buf[0], buf[1],buf[2],buf[3]);
		//printf("DataA: %lu  DataB:  %lu \t", myData0, data);
		//printf("Data_1: %lu HEX: 0x%lu \t", myData1, myData1);
	
		bitClear(isrFlags, F_HAVE_DATA); // Flag we have read the data

		dec2binLong(myData0, 10);
		dec2binLong(myData1, 32);

		Serial.print(" - Battery=");
		byte H = (myData1 >> 30) & 0x3;   // Get Battery
		Serial.print(H);

		Serial.print(" Channel=");
		H = (myData1 >> 28) & 0x3;        // Get Channel  
		H += 1;                           // Channel 1..3 not 0..2   
		Serial.print(H);

		byte ML = (myData1 >> 16) & 0xF0; // Get MMMM
		H = (myData1 >> 24) & 0xF;        // Get LLLL
		ML = ML | H;                      // OR MMMM & LLLL nibbles together
		H = (myData1 >> 16) & 0xF;        // Get HHHH

		int tempFah = ((H << 8) | ML) - 900;  // Combine HHHH MMMMLLLL, Remove Constant offset    
		float tempF = tempFah / 10.0;
		float tempC = ((tempFah / 10.0) - 32) * 5 / 9;

		H = (myData1 >> 4) & 0xF0;    // Get HHHH
		ML = (myData1 >> 12) & 0x0F;    // Get LLLL
		ML = ML | H;                    // OR HHHH & LLLL nibbles together

		Serial.print(" Temperature=");
		Serial.print("[F]: "); Serial.print(tempF, 1); Serial.print("   ");
		Serial.print("[C]: "); Serial.print(tempC, 1); Serial.print("    ");
		Serial.print("Humidity=");
		Serial.print(ML);
		Serial.println("%");

		//--- prepare for next reading
		bitClear(isrFlags, F_GOOD_DATA); //-- flag we have read the data

	}
	//delay(100);
}
// ------------------------------------------------------------------
void process433_start()
{
	Serial.print(F("ISR Pin 2 Configured For Input."));
	attachInterrupt(0, PinChangeISR0, CHANGE);
	isInReadMode = true; 
	Serial.println(F("Pin 2 ISR Function Attached. Here we go..."));
}
// ------------------------------------------------------------------
void process433_stop()
{
	detachInterrupt(0);
	isInReadMode = false;
	Serial.println(F("Pin 2 ISR INT0 Function detached."));
}

// ------------------------------------------------------------------
void LED_on()
{
	Serial.println("LED on");
	digitalWrite(LED_BUILTIN, HIGH);
}
//------------------------------------------------------------------
void LED_off()
{
	Serial.println("LED off");
	digitalWrite(LED_BUILTIN, LOW);
}
//------------------------------------------------------------------
void Blink()
{
	Serial.println("Blinking...");
	for (byte i=0; i<10; i++)
	{
		digitalWrite(LED_BUILTIN, HIGH);
		delay(100);
		digitalWrite(LED_BUILTIN, LOW);
		delay(200);
	}
	Serial.println("Blink done.");
}

//------------------------------------------------------------------
void sayHello()
{
	char *arg;
	arg = sCmd.next();    // Get the next argument from the SerialCommand object buffer
	if (arg != NULL)
	{
		// As long as it existed, take it
		Serial.print("Hello ");
		Serial.println(arg);
	}
	else
	{
		Serial.println("Hello, whoever you are");
	}
}
//------------------------------------------------------------------
void processCommand()
{
	int aNumber;
	char *arg;

	Serial.println("We're in processCommand");
	arg = sCmd.next();
	if (arg != NULL)
	{
		aNumber = atoi(arg);    // Converts a char string to an integer
		Serial.print("First argument was: ");
		Serial.println(aNumber);
	}
	else
	{
		Serial.println("No arguments");
	}

	arg = sCmd.next();
	if (arg != NULL)
	{
		aNumber = atol(arg);
		Serial.print("Second argument was: ");
		Serial.println(aNumber);
	}
	else
	{
		Serial.println("No second argument");
	}
}
//------------------------------------------------------------------
// This gets set as the default handler, and gets called when no other command matches.
void unrecognized(const char *command)
{
	Serial.println("What?");
}
//-------------------------------------------------------------------------------
//--- function that printf and related will use to print
int serial_putchar(char c, FILE* f)
{
	if (c == '\n') serial_putchar('\r', f);
	return Serial.write(c) == 1 ? 0 : 1;
}
//--------------------------------------------------------------------------------------
void dec2binLong(unsigned long myNum, byte NumberOfBits)
{
	if (NumberOfBits <= 32)
	{
		myNum = myNum << (32 - NumberOfBits);
		for (int i = 0; i < NumberOfBits; i++)
		{
			if (bitRead(myNum, 31) == 1)
				Serial.print("1");
			else
				Serial.print("0");
			myNum = myNum << 1;
		}
	}
}
//--------------------------------------------------------------------------------------
/* Examples: 
*	int i = 23;
*	uint ui = UINT_MAX;
*	float f = 23.45f;
*	printBits(sizeof(i), &i);
*	printBits(sizeof(ui), &ui);
*	printBits(sizeof(f), &f);
*/
void printBits(size_t const size, void const * const ptr)
{
	unsigned char *b = (unsigned char*)ptr;
	unsigned char byte;
	int i, j;

	for (i = size - 1; i >= 0; i--)
	{
		for (j = 7; j >= 0; j--)
		{
			byte = (b[i] >> j) & 1;
			printf("%u", byte);
		}
	}
	puts("");
}
//--------------------------------------------------------------------------------------
void PinChangeISR0()
{
	// Pin 2 (Interrupt 0) service routine
	unsigned long Time = micros();                          // Get current time
	if (digitalRead(2) == LOW) 
	{
		// Falling edge
		if (Time > (rise_Time + glitch_Length)) 
		{
			//--- no glitch
			Time = micros() - fall_Time;                        // Subtract last falling edge to get pulse time.
			
			if (bitRead(build_Buffer[1], 31) == 1)
				bitSet(isrFlags, F_CARRY_BIT);
			else
				bitClear(isrFlags, F_CARRY_BIT);

			if (bitRead(isrFlags, F_STATE) == 1) 
			{
				//-- data!
				if ((Time > bit0_MIN) && (Time < bit0_MAX)) 
				{
					//--- 0 bit
					build_Buffer[1] = build_Buffer[1] << 1;
					build_Buffer[0] = build_Buffer[0] << 1;
					if (bitRead(isrFlags, F_CARRY_BIT) == 1)
						bitSet(build_Buffer[0], 0);
					bit_Count++;
				}
				else if ((Time > bit1_MIN) && (Time < bit1_MAX)) 
				{
					//--- 1 bit
					build_Buffer[1] = build_Buffer[1] << 1;
					bitSet(build_Buffer[1], 0);
					build_Buffer[0] = build_Buffer[0] << 1;
					if (bitRead(isrFlags, F_CARRY_BIT) == 1)
						bitSet(build_Buffer[0], 0);
					bit_Count++;
				}
				else
				{
					// Not a 0 or 1 bit so restart data build and check if it's a sync?
					bit_Count = 0;
					build_Buffer[0] = 0;
					build_Buffer[1] = 0;
					bitClear(isrFlags, F_GOOD_DATA);                // Signal data reads dont' match
					bitClear(isrFlags, F_STATE);                    // Set looking for Sync mode
					if ((Time > sync_MIN) && (Time < sync_MAX)) {
						// Sync length okay
						bitSet(isrFlags, F_STATE);                    // Set data mode
					}
				}
				if (bit_Count >= allDataBits) 
				{
					// All bits arrived
					bitClear(isrFlags, F_GOOD_DATA);                // Assume data reads don't match
					if (build_Buffer[0] == read_Buffer[0]) 
					{
						if (build_Buffer[1] == read_Buffer[1])
							bitSet(isrFlags, F_GOOD_DATA);              // Set data reads match
					}
					read_Buffer[0] = build_Buffer[0];
					read_Buffer[1] = build_Buffer[1];
					bitSet(isrFlags, F_HAVE_DATA);                  // Set data available
					bitClear(isrFlags, F_STATE);                    // Set looking for Sync mode
					digitalWrite(LED_EXTERN, HIGH); // Used for debugging
					build_Buffer[0] = 0;
					build_Buffer[1] = 0;
					bit_Count = 0;
				}
			}
			else 
			{
				//--- looking for sync
				if ((Time > sync_MIN) && (Time < sync_MAX)) 
				{
					// Sync length okay
					build_Buffer[0] = 0;
					build_Buffer[1] = 0;
					bit_Count = 0;
					bitSet(isrFlags, F_STATE);                      // Set data mode
					digitalWrite(LED_EXTERN, LOW); // Used for debugging
				}
			}
			fall_Time = micros();                               // Store fall time
		}
	}
	else
	{
		//--- Rising edge
		if (Time > (fall_Time + glitch_Length)) 
		{
			//--- Not a glitch
			rise_Time = Time;                                   // Store rise time
		}
	}
}
//-------------------------------------------------------------------------------
//-------------------------------------------------------------------------------
//------------------------------------------------------------------
//------------------------------------------------------------------